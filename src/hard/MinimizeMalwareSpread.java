package hard;

import java.util.HashSet;
import java.util.Set;

/*
    Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

    We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).
    If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
 */
public class MinimizeMalwareSpread {

    private int count, result, min;

    public static void main(String... args) {

        int[] initial = {5, 0};
        int[][] graph = {{1,0,0,0,0,0}, {0,1,0,0,0,0}, {0,0,1,0,0,0}, {0,0,0,1,1,0}, {0,0,0,1,1,0}, {0,0,0,0,0,1}};
        MinimizeMalwareSpread minimizeMalwareSpread = new MinimizeMalwareSpread();
        System.out.println(minimizeMalwareSpread.minMalwareSpread(graph, initial));
    }

    private void dfs(int n, boolean[] t, Set<Integer>[] e) {

        count++;
        t[n] = true;
        for (int x : e[n]) if (!t[x]) dfs(x, t, e);
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {

        int n = graph.length, result = min = n+1;
        boolean[] f = new boolean[n];
        Set<Integer>[] e = new Set[n];
        for (int x : initial) f[x] = true;

        for (int i = 0; i < n; i++) {

            e[i] = new HashSet<>();

            for (int j = 0; j < n; j++)
                if (graph[i][j] == 1 && i != j)
                    e[i].add(j);
        }

        for (int x : initial) {

            count = 0;
            f[x] = false;
            boolean[] t = new boolean[n];

            for (int i = 0; i < n; i++)
                if (!t[i] && f[i])
                    dfs(i, t, e);

            f[x] = true;

            if (count <= min && x < result) {
                result = x;
                min = count;
            }
        }

        return result;
    }

}
